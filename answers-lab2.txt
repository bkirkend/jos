a. What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:

    +-----+--------------------------------+---------------------------------------+
    |Entry| Base Virtual Address           |  Points to (logically)                |
    +=====+======================+=================================================+
    |1023 | 0xFFC00000                     | Page table for top 4MB of phys memory |
    +-----+--------------------------------+---------------------------------------+
    |1022 | 0xFF800000                     | ?                                     |
    +-----+--------------------------------+---------------------------------------+
    |.    | ?                              | ?                                     |
    +-----+--------------------------------+---------------------------------------+
    |960  | 0xF0000000 (KERNBASE)          | physical memory                       |
    +-----+--------------------------------+---------------------------------------+
    |959  | 0xEFFF8000 (KSTACKTOP-KSTKSIZE)| bootstack                             |
    +-----+--------------------------------+---------------------------------------+
    |957  | 0xEF400000                     | page table                            |
    +-----+--------------------------------+---------------------------------------+
    |956  | 0xEF000000 (UPAGES)            | pages                                 |
    +-----+--------------------------------+---------------------------------------+
    |.    | ?                              | ?                                     |
    +-----+--------------------------------+---------------------------------------+
    |2    | 0x00800000                     | UTEXT                                 |
    +-----+--------------------------------+---------------------------------------+
    |1    | 0x00400000                     | UTEMP                                 |
    +-----+--------------------------------+---------------------------------------+
    |0    | 0x00000000                     | [see next question]                   |
    +-----+--------------------------------+---------------------------------------+

b. We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernelâ€™s memory? What specific mechanisms protect the kernel memory?
There are permission flags that we have set on the page table entries that limit permissions for users and the kernel per page entry and per directory entry. These provide security by only allowing access to be written and read from when the correct permissions are provided. For example, for the mapped pages we set the permission flags to fittingly be accessible by the user by using the PTE_U flag. There is also the PTE_W for being writable for other cases. 

c. What is the maximum amount of physical memory that this operating system can support? Why?
It is 256 MB because the mapped physical memory size is seen as the size of kernbase which is 2^32 - 0xF0000000 which is 256MB

d. How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

One page directory (4096B bytes per page directory)
    -> 1024 page tables (4096 Bytes per pagetable)
    
4096 + (1024 * 4096) = 4MB
amount of overhead = 4MB

e. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

We transition to running at an EIP above KERNBASE after the following instruction: jmp	*%eax; which is on line 68 in entry.S. We are able to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE because there is not just the mapping of va [KERNBASE, KERNBASE + 4MB) to pa [0, 4MB) there is also the mapping va [0, 4MB) to pa [0, 4MB). We need this transition to an EIP above KERNBASE because there are still some instructions to execute in order to jump to a point above KERNBASE once paging has been enabled.